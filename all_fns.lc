zero := (fn f => fn x => x);
succ := fn n => (fn f => fn x => f (n f x));
one := succ zero;
plus := fn n => fn m => (n succ m);
times := fn n => fn m => (fn f => fn x => n (m f) x);
two := succ (succ zero);

true := fn t => fn e => t;
false := fn t => fn e => e;
pair := fn f => fn s (fn c => c f s); 
first := fn p => p true;
second := fn p => p false;
and := fn p => fn q => p q p; 
not_zero := fn m => m;

power := fn n => fn m => m (times n) one;

pred := fn n => first (n fn p => pair (second p) (succ(second p))) pair zero zero);

minus := fn n => fn m => (m pred) n;

less := fn n => fn m => m;

equal := fn n => fn m => n;

Ycomb := fn f => (fn x => (f (x x)) ) ((fn x => (f(x x)))) ;


div := fn x => fn y => fn n => fn m => fn f => (fn p => equal_to_zero p (zero m f) (m (x p n m f))) (minus y n);

div_helper := Ycomb (div);

division := fn y => div_helper (succ y);

fib_rec_helper := fn f => fn n => (if (equals n zero) zero  (if (equals n one) one (plus (f (pred n)) (f (pred (pred n)))  ) )  );

fib_rec := fn n => Ycomb (fib_rec_helper) (three) ;

fibIterator := fn p => pair (plus (first p) (second p)) (first p);

fib_it := fn n => first (n fibIterator (pair one zero));

collatz_next := fn n => if (is_even n) (division n two) (plus one (times n three));

collatz_seq_helper := fn f => fn n => if (equals n one) zero (pair n (collatz_next n) ); 

collatz_seq := fn n => Ycomb (collatz_seq_helper) (n);

is_even_helper := fn f => fn n => if (equal_to_zero n) true (not (f (pred n))) ;

is_even := fn n=> Ycomb (is_even_helper) (n);

main := zero;